\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{wrapfig}

\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{todonotes}


\newtheorem{fact}{Fact}
\newtheorem{redrule}{Reduction Rule}	
\newtheorem{theorem}{Theorem}
\newtheorem{observation}{Observation}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{tlemma}{Technical Lemma}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{center}
CS130A Homework 4 [Due Wednesday March 17th 23:59] \\
\end{center}
%{\bf Name: }

\begin{itemize}
%\item {\bf IMPORTANT} For all tasks labelled $\star$ you need to preface your answer with one of three sentences {\em This is correct}, {\em This may be correct}, or {\em This is not correct}.

%\begin{itemize}
%\item An answer labelled ``This is correct'' can get 100\% of the points, but any {\em substantial} error will result in you getting 0 points for the answer. Errors such as accidentally flipping indices or missing an unimportant corner case will not result in a 0 score. The final judgment on what error is considered substantial is {\em left to the instructors}. 

%\item An answer labelled ``This may be correct'' will be graded normally, but out of (approximately) 80\%. That is, {\em a completely correct answer labelled ``This may be correct''} will receive 80\% of the score. 

%\item An answer labelled ``This is not correct'' will be graded out of approximately 50\%. Here you may write down partial answers and/or any ideas you may have for how to complete the task, and we will grade based on how sensical and relevant these partial answers/ideas are. Bonus points may be awarded for pointing out in what way your answer is incorrect. 
%\end{itemize}

\item You may discuss about homework with your classmates, but you must write down your own solution and acknowledge your collaborators. {\em You must understand and be able to explain every single line that you hand in. Not being able to do so qualifies as cheating.}

\item You may {\em NOT} search for answers to particular problems online; e.g. searching for ``AVL Trees'', or ``Heaps'' is fine. Pasting parts of the question into the search bar and the morally equivalent is not. 

%\item You are allowed to use the lecture notes, any textbook, and Wikipedia as your sources.
%\item Do not forget to write your student number [not name!] when you hand in your answers.
%\item Write the answer directly on the question sheet. 
\item All answers should be explained and justified, unless specified otherwise.
\item This assignment counts for 16\% of your grade. 
\item The points awarded and the weighing scheme may be adjusted - your final grade will not necessarily be precisely a weighted average of your grades for the homeworks / programming assignments.
\end{itemize} 
 
 \newpage 



\begin{enumerate}

\item {\sc BFS and DFS}\label{task:search} (15\%) \newline 

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.4\textwidth, angle=0]{gridGraph_cropped.pdf}
\end{center}
\caption{A graph}\label{fig:1}
\end{figure}
\begin{enumerate}
\item Consider a BFS on the graph $G$ in Figure~\ref{fig:1}, starting at vertex $a$. In the BFS break ties by always going to the lexicographically first vertex. Classify all the edges of $G$ as tree edges,  back edges, and cross edges with respect to the resulting BFS tree. 

\item Consider a DFS on the graph $G$ in Figure~\ref{fig:1}, starting at vertex $a$. In the DFS break ties by always going to the lexicographically first vertex. Classify all the edges of $G$ as tree edges,  back edges, and cross edges with respect to the resulting DFS tree. 

\item Draw a spanning tree $T$ of $G$ from  Figure~\ref{fig:1} rooted at the vertex $a$ so that at least one edge in $G$ is a cross edge and at least one edge is a back edge with respect to $T$.

%\item A graph can be used to represent friendships between people: every vertex corresponds to a person and there is an edge between two vertices if the corresponding people are friends. It is tempting to believe that ``a friend of a friend is a friend''. In other words, whenever $a$ is friends with $b$ and $b$ is friends with $c$, then $a$ is friends with $c$. A graph $G$ is a {\em perfect friendship graph} if the assumption above holds for $G$. Prove that a graph $G$ is a perfect friendship graph if and only if, for every connected component $C$ of $G$, for every pair of distinct vertices $u$, $v$ in $G$, it holds that $uv \in E(G)$.

%\item Give an algorithm that takes as input a graph $G$ and determines whether $G$ is a perfect friendship graph. For full score the running time of your algorithm should be $O(n + m)$.

%\item Argue correctness of your algorithm.

%\item Analyze the running time of your algorithm.
\end{enumerate}


\item {\sc Spanning Trees}\label{task:MST} (25\%) \newline 
Each subtask below contains a statement about minimum spanning trees in undirected graphs with positive edge weights. For each statement determine whether it is true or false. If it is true, give a {\em brief} justification why it is true. If it is false, give a counterexample. 
\begin{enumerate}
\item If all edge weights are unique then the minimum spanning tree is unique.
\item If all edge weights are not unique then the minimum spanning tree is not unique.
\item If $T$ is a minimum spanning tree and $w_{max}$ is the largest edge weight of an edge in $T$, then every spanning tree $T'$ of $G$ must contain at least one edge of weight at least $w_{max}$. 
\item If $uv$ is an edge of minimum weight then every minimum spanning tree of $G$ contains the edge $uv$.
\item If $uv$ is an edge of minimum weight then at least one minimum spanning tree of $G$ contains the edge $uv$. 
\item For every unweighted graph $G$ and spanning tree $T$ of $G$ there exists a weight function $w : E(G) \rightarrow \mathbb{N}$ so that $T$ is the unique minimum spanning tree of $G$.
\item Let $T$ be a minimum spanning tree of $G$ and let $uv$ be an edge in $E(G) \setminus E(T)$. Then $T$ is a minimum spanning tree of $G - uv$ (the graph obtained from $G$ by removing the edge $uv$).
\item Let $T$ be a minimum spanning tree of $G$ and let  $uv \in E(T)$. If $G - uv$ is connected then there exists a minimum spanning tree $T'$ of $G - uv$ so that $E(T) \setminus \{uv\} \subseteq E(T')$. 
\end{enumerate}


\item {\sc Shortest Paths}\label{task:SP} (30\%) \newline 
The instructor team for CS130A (Daniel, Ethan, Peter, Pingyuan, Sean, Yuval) find themselves located in an undirected graph $G$ with positive edge weights $w : E(G) \rightarrow \mathbb{N}$. Daniel, Ethan, Peter, Pingyuan, Sean, Yuval start in vertex $s_1$, $s_2$, $s_3$, $s_4$, $s_5$ and $s_6$ respectively. They would like to meet each other in a vertex $v$ to make an algorithms problem. But they all have to be gathered at the same vertex $v$ to discuss! If a vertex $v$ is chosen as a meeting spot then everyone goes to $v$ along a shortest path, from their starting position, and everyone moves at the same speed. Here the time to traverse an edge is proportional to its weight. Help the CS130A team find the vertex $v$ that minimizes the time until the last team member arrives at $v$. 

\begin{enumerate}
\item Design an algorithm that given as input $G$, edge weights $w : E(G) \rightarrow \mathbb{N}$, and $s_1$, $s_2$, $s_3$, $s_4$, $s_5$ and $s_6$  finds a vertex $v$ that minimizes $\max_{i \leq 6} d(s_i, v)$. Here $d(u,v)$ is the shortest path distance from $u$ to $v$ in $G$. For full score the running time of your algorithm should be $O((n + m)\log n)$ or better.

\item Argue correctness for your algorithm.

\item Analyze the running time of your algorithm.
\end{enumerate}





\item {\sc Segment Trees} \label{task:SP} (30\%) \newline 
%\item A segment tree stores an array $A = \{1,2,3,4,5,6,7,8\}$ (the array is $1$-indexed so $A[1] = 1$). Draw the initial state of the segment tree, as well as the state of the segment tree after the operations $A[4] = 10$ followed by $A[8] = 2$.
%
Johnny loves hiking tall montains. One summer he finds himself in a long mountain range. This terrain is arranged in a line from east to west, with the westernmost point at position $1$ and the easternmost point at position $n$. The height above sea level of position $i$ is given by a positive integer $h_i$. Initially, Johnny starts at position $p$, with $1 \leq p \leq n$. 

Johnny is very fit, so how far he can walk on any given day is not limited by distance at all. However, he does not want to suffer from altitude sickness. On any given day he will suffer from altitude sickness if he ever visits an altitude which is too high or too low compared to where he was at the beginning of the day. How much height difference he can tolarate varies from day to day. 

For each day $j$ his height difference tolerance is given by a positive integer $d_j$. In particular, if he starts the day $j$ on position $p_j$, and therefore at altitude $h_{p_j}$, he will suffer altitude sickness if he visits any position whose altitude is outside of the range $\{h_{p_j} - d_j, \ldots, h_{p_j} + d_j\}$.

On the first day, Johnny travels west as far as he can - until he either reaches the end of the mountain range or moving further west would give him altitude sickness. The position where Johnny stops is $p_{j+1}$ - the ending position of day $j$ and also the starting position for day $j+1$. The next day Johnny travels east as far as he can, again until he reaches the end of the mountain range or moving further east would give him altitude sickness. He continues zig-zagging this way for all of the $m$ days of summer. 
\begin{enumerate}
\item Design an algorithm that given $n$, the height profile $h_1, \ldots, h_n$ of the mountain range, the starting position $p$ of Johnny, the number $m$ of days of summer, and Johnny's height difference tolerance $d_1, \ldots d_m$ for each of the days of summer, outputs for every day $j \leq m$ the position $p_{j+1}$ where Johnny decides to rest for the day. For full score the running time of your algorithm should be $O((n + m) \log^2 n)$ or better. Bonus points for an algorithm running in time $O((n + m) \log n)$ or better.

\item Argue correctness of your algorithm. 

\item Analyze the running time of your algorithm.
\end{enumerate}




\end{enumerate}

\end{document}